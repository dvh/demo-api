const fs = require('node:fs');
const path = require('node:path');
const jsYaml = require('js-yaml');
const config = require('../config');
const logger = require('../logger');

class Service {
  static rejectResponse(error, code = 500) {
    return { error, code };
  }

  static successResponse(payload, code = 200) {
    return { payload, code };
  }

  static isErrorResponse(result) {
    return Boolean(result
      && Object.prototype.hasOwnProperty.call(result, 'error')
      && Object.prototype.hasOwnProperty.call(result, 'code'));
  }

  static normalizeSuccessResponse(result) {
    if (result === undefined) {
      return undefined;
    }
    if (result && Object.prototype.hasOwnProperty.call(result, 'payload')) {
      return result;
    }
    return Service.successResponse(result);
  }

  static getMockModule(serviceName) {
    if (!config.USE_MOCKS) {
      return null;
    }
    if (!Object.prototype.hasOwnProperty.call(Service.mockModules, serviceName)) {
      const mockPath = path.join(config.MOCK_DIR, `${serviceName}.js`);
      if (!fs.existsSync(mockPath)) {
        Service.mockModules[serviceName] = null;
        return null;
      }
      try {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        Service.mockModules[serviceName] = require(mockPath);
      } catch (error) {
        logger.error(`Unable to load mock implementation for ${serviceName}: ${error.message}`);
        Service.mockModules[serviceName] = null;
      }
    }
    return Service.mockModules[serviceName];
  }

  /**
   * Returns undefined when no mock is available. Otherwise resolves to an object describing
   * how the caller should respond (resolve/reject) with the normalized payload.
   */
  static async applyMock(serviceName, operationId, params) {
    if (!config.USE_MOCKS) {
      return undefined;
    }
    let autoMockEvaluated = false;
    let autoMock;
    const resolveAutoMock = () => {
      if (!autoMockEvaluated) {
        autoMock = Service.generateAutoMock(operationId);
        autoMockEvaluated = true;
      }
      return autoMock;
    };
    const mockModule = Service.getMockModule(serviceName);
    if (!mockModule) {
      const generated = resolveAutoMock();
      if (generated !== undefined) {
        logger.info(`[Mock] Using autogenerated payload for ${serviceName}.${operationId}`);
        return { action: 'resolve', value: generated };
      }
      return undefined;
    }
    const handler = mockModule[operationId];
    if (typeof handler !== 'function') {
      const generated = resolveAutoMock();
      if (generated !== undefined) {
        logger.info(`[Mock] Using autogenerated payload for ${serviceName}.${operationId}`);
        return { action: 'resolve', value: generated };
      }
      return undefined;
    }
    try {
      const result = await handler(params);
      if (result === undefined) {
        const generated = resolveAutoMock();
        if (generated !== undefined) {
          logger.info(`[Mock] Using autogenerated payload for ${serviceName}.${operationId}`);
          return { action: 'resolve', value: generated };
        }
        return undefined;
      }
      if (Service.isErrorResponse(result)) {
        logger.info(`[Mock] Returning custom error response for ${serviceName}.${operationId}`);
        return { action: 'reject', value: result };
      }
      logger.info(`[Mock] Returning custom mock payload for ${serviceName}.${operationId}`);
      return { action: 'resolve', value: Service.normalizeSuccessResponse(result) };
    } catch (error) {
      if (Service.isErrorResponse(error)) {
        logger.warn(`[Mock] Mock handler threw mock error for ${serviceName}.${operationId}`);
        return { action: 'reject', value: error };
      }
      throw error;
    }
  }

  static getApiDoc() {
    if (Service.apiDoc !== undefined) {
      return Service.apiDoc;
    }
    try {
      const specContents = fs.readFileSync(config.OPENAPI_YAML, 'utf8');
      Service.apiDoc = jsYaml.safeLoad(specContents);
    } catch (error) {
      logger.error(`Unable to load OpenAPI spec for auto mocks: ${error.message}`);
      Service.apiDoc = null;
    }
    return Service.apiDoc;
  }

  static buildOperationIndex() {
    if (Service.operationIndex !== undefined) {
      return Service.operationIndex;
    }
    const apiDoc = Service.getApiDoc();
    const index = {};
    if (apiDoc && apiDoc.paths) {
      Object.keys(apiDoc.paths).forEach((pathKey) => {
        const pathItem = apiDoc.paths[pathKey];
        Object.keys(pathItem).forEach((methodKey) => {
          const operation = pathItem[methodKey];
          if (!operation || typeof operation !== 'object' || !operation.operationId) {
            return;
          }
          const { operationId } = operation;
          if (!operationId) {
            return;
          }
          const entry = {
            path: pathKey,
            method: methodKey,
            operation,
          };
          index[operationId] = entry;
          const sanitizedId = Service.sanitizeOperationId(operationId);
          if (sanitizedId && sanitizedId !== operationId) {
            index[sanitizedId] = entry;
          }
          const lowerId = operationId.toLowerCase();
          if (lowerId !== operationId && lowerId !== sanitizedId
            && !Object.prototype.hasOwnProperty.call(index, lowerId)) {
            index[lowerId] = entry;
          }
        });
      });
    }
    Service.operationIndex = index;
    return index;
  }

  static resolveRef(ref) {
    if (typeof ref !== 'string' || !ref.startsWith('#/')) {
      return undefined;
    }
    const apiDoc = Service.getApiDoc();
    if (!apiDoc) {
      return undefined;
    }
    const parts = ref.replace('#/', '').split('/');
    let current = apiDoc;
    for (let i = 0; i < parts.length; i += 1) {
      const part = parts[i];
      if (!Object.prototype.hasOwnProperty.call(current, part)) {
        return undefined;
      }
      current = current[part];
    }
    return current;
  }

  static sanitizeOperationId(operationId) {
    if (!operationId || typeof operationId !== 'string') {
      return null;
    }
    let result = operationId.trim();
    if (result.length === 0) {
      return null;
    }
    result = result.replace(/[_-]+/g, ' ');
    result = result.replace(/[^a-zA-Z0-9_$]+/g, ' ');
    result = result.split(' ').filter((segment) => segment.length > 0)
      .map((segment, index) => {
        if (index === 0) {
          return segment;
        }
        return segment.charAt(0).toUpperCase() + segment.slice(1);
      }).join('');
    result = result.replace(/^[^a-zA-Z_$]+/, '');
    if (result.length === 0) {
      return null;
    }
    return result.charAt(0).toLowerCase() + result.slice(1);
  }

  static pickPreferredMedia(content) {
    if (!content || typeof content !== 'object') {
      return null;
    }
    if (content['application/json']) {
      return content['application/json'];
    }
    if (content['application/problem+json']) {
      return content['application/problem+json'];
    }
    const firstKey = Object.keys(content)[0];
    return firstKey ? content[firstKey] : null;
  }

  static clone(value) {
    if (value === undefined) {
      return value;
    }
    try {
      return JSON.parse(JSON.stringify(value));
    } catch (error) {
      return value;
    }
  }

  static primitiveExample(schema) {
    if (!schema || typeof schema !== 'object') {
      return null;
    }
    if (schema.example !== undefined) {
      return Service.clone(schema.example);
    }
    if (schema.default !== undefined) {
      return Service.clone(schema.default);
    }
    if (schema.enum && schema.enum.length > 0) {
      return Service.clone(schema.enum[0]);
    }
    switch (schema.type) {
      case 'string':
        if (schema.format === 'date-time') return new Date().toISOString();
        if (schema.format === 'date') return new Date().toISOString().split('T')[0];
        if (schema.format === 'uuid') return '00000000-0000-4000-8000-000000000000';
        return 'string';
      case 'integer':
      case 'number':
        return 0;
      case 'boolean':
        return true;
      default:
        return null;
    }
  }

  static generateExampleFromSchema(schema, stack = new Set()) {
    if (!schema || typeof schema !== 'object') {
      return undefined;
    }
    if (schema.$ref) {
      if (stack.has(schema.$ref)) {
        return undefined;
      }
      stack.add(schema.$ref);
      const resolved = Service.resolveRef(schema.$ref);
      if (!resolved) {
        return undefined;
      }
      const result = Service.generateExampleFromSchema(resolved, stack);
      stack.delete(schema.$ref);
      return result;
    }

    const primitive = Service.primitiveExample(schema);
    if (primitive !== null) {
      return primitive;
    }

    if (schema.type === 'array') {
      const itemExample = Service.generateExampleFromSchema(schema.items, stack);
      return itemExample !== undefined ? [itemExample] : [];
    }

    if (schema.type === 'object' || schema.properties) {
      const obj = {};
      const properties = schema.properties || {};
      const propertyNames = Object.keys(properties);
      propertyNames.forEach((name) => {
        const exampleValue = Service.generateExampleFromSchema(properties[name], stack);
        if (exampleValue !== undefined) {
          obj[name] = exampleValue;
        }
      });
      if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
        const additionalExample = Service.generateExampleFromSchema(schema.additionalProperties, stack);
        if (additionalExample !== undefined) {
          obj.additionalProperty = additionalExample;
        }
      }
      return obj;
    }

    if (schema.allOf && Array.isArray(schema.allOf)) {
      return schema.allOf.reduce((acc, partialSchema) => {
        const partialExample = Service.generateExampleFromSchema(partialSchema, stack);
        if (partialExample === undefined) {
          return acc;
        }
        if (partialExample && typeof partialExample === 'object' && !Array.isArray(partialExample)) {
          return { ...acc, ...partialExample };
        }
        return partialExample;
      }, {});
    }

    if (schema.oneOf && Array.isArray(schema.oneOf) && schema.oneOf.length > 0) {
      return Service.generateExampleFromSchema(schema.oneOf[0], stack);
    }

    if (schema.anyOf && Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {
      return Service.generateExampleFromSchema(schema.anyOf[0], stack);
    }

    return undefined;
  }

  static extractExampleFromResponse(response) {
    if (!response) {
      return undefined;
    }
    let resolvedResponse = response;
    if (typeof resolvedResponse === 'string') {
      const dereferenced = Service.resolveRef(resolvedResponse);
      if (dereferenced) {
        resolvedResponse = dereferenced;
      }
    }
    if (resolvedResponse && typeof resolvedResponse === 'object' && resolvedResponse.$ref) {
      const dereferenced = Service.resolveRef(resolvedResponse.$ref);
      if (dereferenced) {
        resolvedResponse = dereferenced;
      }
    }
    if (!resolvedResponse || typeof resolvedResponse !== 'object') {
      return undefined;
    }
    const media = Service.pickPreferredMedia(resolvedResponse.content);
    if (!media) {
      return undefined;
    }
    if (media.example !== undefined) {
      return Service.clone(media.example);
    }
    if (media.examples && typeof media.examples === 'object') {
      const firstExample = Object.values(media.examples)[0];
      if (firstExample && typeof firstExample === 'object') {
        if (firstExample.value !== undefined) {
          return Service.clone(firstExample.value);
        }
      }
    }
    if (media.schema) {
      return Service.generateExampleFromSchema(media.schema);
    }
    return undefined;
  }

  static pickResponse(operation) {
    if (!operation || !operation.responses) {
      return null;
    }
    const preferredStatuses = ['200', '201', '202', '204'];
    for (let i = 0; i < preferredStatuses.length; i += 1) {
      const status = preferredStatuses[i];
      if (operation.responses[status]) {
        return { status, response: operation.responses[status] };
      }
    }
    const statusCodes = Object.keys(operation.responses);
    if (statusCodes.length === 0) {
      return null;
    }
    return { status: statusCodes[0], response: operation.responses[statusCodes[0]] };
  }

  static generateAutoMock(operationId) {
    const operationIndex = Service.buildOperationIndex();
    const operationEntry = operationIndex[operationId];
    if (!operationEntry) {
      return undefined;
    }
    const { operation } = operationEntry;
    const responseInfo = Service.pickResponse(operation);
    if (!responseInfo) {
      return undefined;
    }
    const examplePayload = Service.extractExampleFromResponse(responseInfo.response);
    const parsedStatus = Number.parseInt(responseInfo.status, 10);
    const statusCode = Number.isNaN(parsedStatus) ? 200 : parsedStatus;
    if (examplePayload === undefined) {
      return Service.successResponse({
        message: `Auto-generated mock for ${operationId}`,
      }, statusCode);
    }
    return Service.successResponse(examplePayload, statusCode);
  }
}

Service.mockModules = {};
Service.apiDoc = undefined;
Service.operationIndex = undefined;

module.exports = Service;
